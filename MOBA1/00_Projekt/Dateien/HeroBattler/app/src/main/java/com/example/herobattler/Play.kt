package com.example.herobattler

import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup

import com.example.herobattler.databinding.FragmentPlayBinding
import android.content.pm.ActivityInfo


import android.text.Editable
import android.text.TextWatcher
import androidx.fragment.app.activityViewModels


class Play : Fragment() {
    private var _binding: FragmentPlayBinding? = null

    private val binding get() = _binding!!

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?): View? {
        //adapt also this name (the class will be autogenerated)
        _binding = FragmentPlayBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        activity?.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE

        val model: CharactersModel by activityViewModels()
        context?.let { model.loadCharacter(it) }
        val baseCharacters = model.getMutableListOfCharacters()

        binding.choosePlayer1.addTextChangedListener(object : TextWatcher {
            override fun afterTextChanged(s: Editable?) {

                loadCharacter1(binding.choosePlayer1.text.toString(), baseCharacters)
            }

            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
            }

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
            }
        })

        binding.choosePlayer2.addTextChangedListener(object : TextWatcher {
            override fun afterTextChanged(s: Editable?) {

                loadCharacter2(binding.choosePlayer2.text.toString(), baseCharacters)
            }

            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
            }

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
            }
        })


        binding.attackButton.setOnClickListener {
            val character = baseCharacters.find { it.characterName == binding.player2Name.text  }
            if (character != null && binding.damageToHP.text.toString() != null) {

                var hpValue =
                    character.characterHP.toInt() - binding.damageToHP.text.toString().toInt()

                if(hpValue <= 0)
                {
                    hpValue = 0
                }
                character.characterHP = hpValue.toString()


                loadCharacter2(character.characterName, baseCharacters)
                saveIntoFile(model, character)
            }
        }

        binding.healButton.setOnClickListener {
            val character = baseCharacters.find { it.characterName == binding.player2Name.text  }
            if (character != null && binding.damageToHP.text.toString() != null) {

                var hpValue =
                    character.characterHP.toInt() + binding.damageToHP.text.toString().toInt()

                if(hpValue >= character.characterMaxHP.toInt())
                {
                    hpValue = character.characterMaxHP.toInt()
                }
                character.characterHP = hpValue.toString()


                loadCharacter2(character.characterName, baseCharacters)
                saveIntoFile(model, character)
            }
        }
    }

    fun saveIntoFile(model: CharactersModel, character: Character) {

        context?.let {
            model.deleteCharacter(
                character.characterName, it)
        }

        context?.let {
            model.addCharacter(
                character.characterName,
                character.characterLevel,
                character.characterClass,
                character.characterRace,
                character.characterHP,
                character.characterMaxHP, it)
        }
    }

    private fun loadCharacter1(choice: String, baseCharacters: MutableList<Character>){
        for( char in baseCharacters){
            if((char.characterName) == choice){
                binding.player1Name.text = char.characterName
                binding.player1Level.text = char.characterLevel
                binding.player1Class.text = char.characterClass
                binding.player1Race.text = char.characterRace
                binding.player1HP.text = char.characterHP + " (" + char.characterMaxHP + ")"
            }
        }
    }
    private fun loadCharacter2(choice: String, baseCharacters: MutableList<Character>){
        for( char in baseCharacters){
            if((char.characterName) == choice){
                binding.player2Name.text = char.characterName
                binding.player2Level.text = char.characterLevel
                binding.player2Class.text = char.characterClass
                binding.player2Race.text = char.characterRace
                binding.player2HP.text = char.characterHP + " (" + char.characterMaxHP + ")"
            }
        }
    }
}